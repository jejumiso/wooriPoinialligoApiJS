"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootpay = void 0;
const resource_1 = require("./lib/resource");
class BootpayBackendNodejs extends resource_1.BootpayBackendNodejsResource {
    constructor() {
        super();
    }
    /**
     * Get Access Token
     * Comment by GOSOMI
     * @returns Promise<AccessTokenResponseParameters>
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { application_id, private_key } = this.bootpayConfiguration;
                const response = yield this.post('request/token', {
                    application_id,
                    private_key
                });
                // set Token
                this.setToken(response.access_token);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * Lookup Receipt
     * Comment by GOSOMI
     * @param receiptId: string
     * @param lookupUserData: boolean
     */
    receiptPayment(receiptId_1) {
        return __awaiter(this, arguments, void 0, function* (receiptId, lookupUserData = false) {
            try {
                const response = yield this.get(`receipt/${receiptId}?lookup_user_data=${lookupUserData ? 'true' : 'false'}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * Cancel Payment
     * Comment by GOSOMI
     * @param cancelPayment: CancelPaymentParameters
     * @returns Promise<CancelPaymentParameters>
     */
    cancelPayment(cancelPayment) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('cancel', Object.assign({}, cancelPayment));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * Lookup Certificate Data
     * Comment by GOSOMI
     * @param receiptId: string
     * @returns Promise<CertificateResponseParameters>
     */
    certificate(receiptId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.get(`certificate/${receiptId}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * ConfirmPayment
     * Comment by GOSOMI
     * @param receiptId: string
     * @returns Promise<ReceiptResponseParameters>
     */
    confirmPayment(receiptId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('confirm', {
                    receipt_id: receiptId
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * lookupSubscribeBillingKey
     * Comment by GOSOMI
     * @param receiptId: string
     * @returns Promise<SubscriptionBillingResponseParameters>
     */
    lookupSubscribeBillingKey(receiptId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.get(`subscribe/billing_key/${receiptId}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * lookupBillingKey
     * Comment by ehowlsla
     * @param billingKey: string
     * @returns Promise<SubscriptionBillingResponseParameters>
     */
    lookupBillingKey(billingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.get(`billing_key/${billingKey}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * requestSubscribeBillingKey
     * Comment by GOSOMI
     * @param subscriptionBillingRequest: SubscriptionBillingRequestParameters
     * @returns Promise<SubscriptionBillingResponseParameters>
     */
    requestSubscribeBillingKey(subscriptionBillingRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/subscribe', Object.assign({}, subscriptionBillingRequest));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * requestSubscribeCardPayment
     * Comment by GOSOMI
     * @param subscriptionCardRequest: SubscriptionCardPaymentRequestParameters
     * @returns Promise<ReceiptResponseParameters>
     */
    requestSubscribeCardPayment(subscriptionCardRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('subscribe/payment', Object.assign({}, subscriptionCardRequest));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * requestSubscribePayment
     * Comment by ehowlsla
     * @param subscriptionRequest: SubscriptionPaymentRequestParameters
     * @returns Promise<ReceiptResponseParameters>
     */
    requestSubscribePayment(subscriptionRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('subscribe/payment', Object.assign({}, subscriptionRequest));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * destroyBillingKey
     * Comment by GOSOMI
     * @param billingKey:string
     * @returns Promise<DestroySubscribeResponseParameters>
     */
    destroyBillingKey(billingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.delete(`subscribe/billing_key/${billingKey}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * requestUserToken
     * Comment by GOSOMI
     * @param userTokenRequest:UserTokenRequestParameters
     * @returns Promise<UserTokenResponseParameters>
     */
    requestUserToken(userTokenRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/user/token', Object.assign({}, userTokenRequest));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * subscribePaymentReserve
     * Comment by GOSOMI
     * @param subscribePaymentReserveRequest:SubscribePaymentReserveParameters
     * @returns Promise<SubscribePaymentReserveResponse>
     */
    subscribePaymentReserve(subscribePaymentReserveRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('subscribe/payment/reserve', Object.assign({}, subscribePaymentReserveRequest));
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * SubscribeReserve Lookup
     * Comment by GOSOMI
     * @date: 2023-03-07
     * @param reserveId: string
     * @returns Promise<SubscribeLookupResponse>
     */
    subscribePaymentReserveLookup(reserveId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.get(`subscribe/payment/reserve/${reserveId}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * cancelSubscribeReserve
     * Comment by GOSOMI
     * @param reserveId:string
     * @returns Promise<CancelSubscribeReserveResponse>
     */
    cancelSubscribeReserve(reserveId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.delete(`subscribe/payment/reserve/${reserveId}`);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 배송시작 REST API 시작
     * Comment by GOSOMI
     * @date: 2022-06-14
     */
    shippingStart(shippingRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.put(`escrow/shipping/start/${shippingRequest.receipt_id}`, shippingRequest);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 기존결제 현금영수증 발행 API
     * Comment by GOSOMI
     * @date: 2022-07-28
     */
    cashReceiptPublishOnReceipt(cashReceiptPublishRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/receipt/cash/publish', cashReceiptPublishRequest);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 기존 결제 현금영수증 발행 취소 API
     * Comment by GOSOMI
     * @date: 2022-08-09
     */
    cashReceiptCancelOnReceipt(cashReceiptCancelRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.delete(`request/receipt/cash/cancel/${cashReceiptCancelRequest.receipt_id}`, {
                    params: cashReceiptCancelRequest
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 별건 현금영수증 발행하기
     * Comment by GOSOMI
     * @date: 2022-08-09
     */
    requestCashReceipt(cashReceiptRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/cash/receipt', cashReceiptRequest);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 별건 현금영수증 취소하기
     * Comment by GOSOMI
     * @date: 2022-08-09
     */
    cancelCashReceipt(cancelCashReceiptRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.delete(`request/cash/receipt/${cancelCashReceiptRequest.receipt_id}`, {
                    params: cancelCashReceiptRequest
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 본인인증 REST API 요청
     * Comment by GOSOMI
     * @date: 2022-11-07
     */
    requestAuthentication(authenticateRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/authentication', authenticateRequest);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 본인인증 승인하기
     * Comment by GOSOMI
     * @date: 2022-11-07
     */
    confirmAuthentication(receipt_id_1) {
        return __awaiter(this, arguments, void 0, function* (receipt_id, otp = null) {
            try {
                const response = yield this.post('authenticate/confirm', {
                    receipt_id,
                    otp
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 본인인증 SMS 재전송
     * Comment by GOSOMI
     * @date: 2022-11-07
     */
    realarmAuthentication(receipt_id) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('authenticate/realarm', {
                    receipt_id
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 계좌 자동이체를 위한 빌링키 발급 요청
     * Comment by ehowlsla
     * @date: 2024-05-27
     */
    requestSubscribeAutomaticTransferBillingKey(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/subscribe/automatic-transfer', parameters);
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    /**
     * 계좌 자동이체를 위한 출금 동의 확인 요청
     * Comment by ehowlsla
     * @date: 2024-05-27
     */
    publishAutomaticTransferBillingKey(receipt_id) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield this.post('request/subscribe/automatic-transfer/publish', {
                    "receipt_id": receipt_id
                });
                return Promise.resolve(response);
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
}
const Bootpay = new BootpayBackendNodejs();
exports.Bootpay = Bootpay;
exports.default = Bootpay;
__exportStar(require("./lib/response"), exports);
__exportStar(require("./lib/resource"), exports);
